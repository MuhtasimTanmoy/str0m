use itertools::Itertools;
use std::{
    collections::{HashMap, VecDeque},
    time::{Duration, Instant},
};

use crate::{media::Source, Mid, Rtc};
use rtp::Rid;

pub struct Stats {
    last_snapshot: StatsSnapshot,
    events: VecDeque<StatEvent>,
}

type Bytes = u64;

pub struct StatsSnapshot {
    peer_tx: Bytes,
    peer_rx: Bytes,
    tx: Bytes,
    rx: Bytes,
    ingress: HashMap<(Mid, Option<Rid>), Bytes>,
    egress: HashMap<(Mid, Option<Rid>), Bytes>,
    ts: Instant,
}

impl StatsSnapshot {
    fn new(ts: Instant) -> StatsSnapshot {
        // TODO: is there a way to only provide the `ts` property
        // which does not conform to Default,
        // and have the rest generated by ..Default::default() ?
        StatsSnapshot {
            peer_rx: 0,
            peer_tx: 0,
            tx: 0,
            rx: 0,
            ingress: HashMap::new(),
            egress: HashMap::new(),
            ts,
        }
    }

    pub fn from(rtc: &mut Rtc, now: Instant) -> StatsSnapshot {
        let session = &mut rtc.session;
        let peer_tx = rtc.peer_bytes_tx;
        let peer_rx = rtc.peer_bytes_rx;
        let rx: Bytes = session
            .media()
            .flat_map(|m| &m.sources_rx)
            .map(|s| s.bytes_rx)
            .sum();
        let tx: Bytes = session
            .media()
            .flat_map(|m| &m.sources_tx)
            .map(|s| s.bytes_tx)
            .sum();

        let egress = {
            let mut data: HashMap<(Mid, Option<Rid>), Bytes> = HashMap::new();

            for media in session.media() {
                let mid = media.mid();
                for (rid, receiver) in media.sources_rx.iter().group_by(|s| s.rid()).into_iter() {
                    let total: Bytes = receiver.map(|s| s.bytes_rx).sum();
                    data.insert((mid, rid), total);
                }
            }
            data
        };

        let ingress = {
            let mut data: HashMap<(Mid, Option<Rid>), Bytes> = HashMap::new();

            for media in session.media() {
                let mid = media.mid();
                for (rid, sender) in media.sources_tx.iter().group_by(|s| s.rid()).into_iter() {
                    let total: Bytes = sender.map(|s| s.bytes_tx).sum();
                    data.insert((mid, rid), total);
                }
            }
            data
        };

        StatsSnapshot {
            peer_tx,
            peer_rx,
            tx,
            rx,
            ingress,
            egress,
            ts: now,
        }
    }
}

const TIMING_ADVANCE: Duration = Duration::from_secs(1);

impl Stats {
    pub fn new() -> Stats {
        Stats {
            // by starting with the current time we can generate stats right away
            last_snapshot: StatsSnapshot::new(Instant::now()),
            events: VecDeque::new(),
        }
    }

    /// returns true if we want to handle the timeout
    ///
    /// This is used to give the caller a chance to collect inputs only if needed
    pub fn handles_timeout(&mut self, now: Instant) -> bool {
        let min_step = self.last_snapshot.ts + TIMING_ADVANCE;
        now >= min_step
    }

    /// Actually handles the timeout advancing the internal state and preparing the output
    pub fn do_handle_timeout(&mut self, snapshot: StatsSnapshot) {
        let elapsed = (snapshot.ts - self.last_snapshot.ts).as_secs_f32();
        let ts = snapshot.ts;

        // enqueue stas and timestampt them so they can be sent out

        let event = PeerStats {
            peer_bitrate_rx: (snapshot.peer_rx - self.last_snapshot.peer_rx) as f32 * 8.0 / elapsed,
            peer_bitrate_tx: (snapshot.peer_tx - self.last_snapshot.peer_tx) as f32 * 8.0 / elapsed,
            bitrate_rx: (snapshot.rx - self.last_snapshot.rx) as f32 * 8.0 / elapsed,
            bitrate_tx: (snapshot.tx - self.last_snapshot.tx) as f32 * 8.0 / elapsed,
            ts: snapshot.ts,
        };

        self.events.push_back(StatEvent::PeerStats(event));

        for ((mid, rid), total) in &snapshot.ingress {
            let (mid, rid, total) = (*mid, *rid, *total);
            let key = (mid, rid);
            let bytes = self.last_snapshot.ingress.get(&key).unwrap_or(&0_u64);
            let bitrate_rx = (total - bytes) as f32 * 8.0 / elapsed;
            let event = MediaIngressStats {
                mid,
                rid,
                bitrate_rx,
                ts,
                // TODO
                remote: RemoteEgressStats { bitrate_rx: 0.0 },
            };
            self.events.push_back(StatEvent::MediaIngressStats(event));
        }

        for ((mid, rid), total) in &snapshot.egress {
            let (mid, rid, total) = (*mid, *rid, *total);
            let key = (mid, rid);
            let bytes = self.last_snapshot.ingress.get(&key).unwrap_or(&0_u64);
            let bitrate_tx = (total - bytes) as f32 * 8.0 / elapsed;
            let event = MediaEgressStats {
                mid,
                rid,
                bitrate_tx,
                ts,
                // TODO
                remote: RemoteIngressStats { bitrate_rx: 0.0 },
            };
            self.events.push_back(StatEvent::MediaEgressStats(event));
        }

        self.last_snapshot = snapshot;
    }

    /// Poll for the next time to call [`self::handle_timeout`].
    ///
    /// NOTE: we only need Option<_> to conform to .soonest() (see caller)
    pub fn poll_timeout(&mut self) -> Option<Instant> {
        let last_now = self.last_snapshot.ts;
        Some(last_now + TIMING_ADVANCE)
    }

    pub fn poll_output(&mut self) -> Option<StatEvent> {
        self.events.pop_front()
    }
}

// Output events

#[derive(Debug, Clone)]
pub enum StatEvent {
    PeerStats(PeerStats),
    MediaEgressStats(MediaEgressStats),
    MediaIngressStats(MediaIngressStats),
}

#[derive(Debug, Clone)]
pub struct PeerStats {
    pub peer_bitrate_rx: f32,
    pub peer_bitrate_tx: f32,
    pub bitrate_rx: f32,
    pub bitrate_tx: f32,
    pub ts: Instant,
}

#[derive(Debug, Clone)]
pub struct MediaEgressStats {
    pub mid: Mid,
    pub rid: Option<Rid>,

    pub bitrate_tx: f32,
    pub ts: Instant,
    // TODO
    pub remote: RemoteIngressStats,
}

#[derive(Debug, Clone)]
pub struct RemoteIngressStats {
    pub bitrate_rx: f32,
}

#[derive(Debug, Clone)]
pub struct MediaIngressStats {
    pub mid: Mid,
    pub rid: Option<Rid>,

    pub bitrate_rx: f32,
    pub ts: Instant,
    // TODO
    pub remote: RemoteEgressStats,
}

#[derive(Debug, Clone)]
pub struct RemoteEgressStats {
    pub bitrate_rx: f32,
}
